// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: person.proto

#ifndef PROTOBUF_person_2eproto__INCLUDED
#define PROTOBUF_person_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_person_2eproto();
void protobuf_AssignDesc_person_2eproto();
void protobuf_ShutdownFile_person_2eproto();

class Register_Request;
class Message_Normal;
class Command;
class Message_;

enum message_type {
  normal = 1,
  sound = 2,
  video = 3,
  unknown = 4,
  system_ = 5,
  query_friend = 6,
  query_friend_ack = 7,
  group = 8,
  file_message = 9
};
bool message_type_IsValid(int value);
const message_type message_type_MIN = normal;
const message_type message_type_MAX = file_message;
const int message_type_ARRAYSIZE = message_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* message_type_descriptor();
inline const ::std::string& message_type_Name(message_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    message_type_descriptor(), value);
}
inline bool message_type_Parse(
    const ::std::string& name, message_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<message_type>(
    message_type_descriptor(), name, value);
}
enum Command_Type {
  add_friend = 1,
  get_friend_info = 2,
  delete_friend = 3,
  change_other = 4,
  change_my_name = 5,
  change_my_passwd = 6,
  change_my_status = 7,
  quit = 8,
  register_request = 9,
  login_request = 10,
  login_respnose = 11,
  error = 12,
  heart = 13,
  request_address = 14,
  udp_ack = 15,
  add_friend_ack = 16,
  friend_message = 17,
  not_ok = 18,
  get_friend_address = 19,
  friend_login = 20,
  friend_exit = 21,
  create_group = 22,
  group_message = 23,
  change_friend_palace = 24,
  remove_my_friend = 25,
  change_mymaxim__ = 26,
  exit_group = 27,
  joinGroupRequest = 28,
  groupmessage = 29,
  camera_direct_send = 30,
  camera_direct_recv = 31,
  camera_direct_send_ack = 32,
  camera_direct_recv_ack = 33,
  camera_end = 34,
  open_file_tcp = 35,
  open_file_tcp_infor = 36,
  file_detail = 37,
  file_download = 38,
  file_upload__ = 39,
  passwd_protect = 40,
  findbackcode = 41,
  passwd_change = 42,
  heat_ack = 43
};
bool Command_Type_IsValid(int value);
const Command_Type Command_Type_MIN = add_friend;
const Command_Type Command_Type_MAX = heat_ack;
const int Command_Type_ARRAYSIZE = Command_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_Type_descriptor();
inline const ::std::string& Command_Type_Name(Command_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_Type_descriptor(), value);
}
inline bool Command_Type_Parse(
    const ::std::string& name, Command_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command_Type>(
    Command_Type_descriptor(), name, value);
}
// ===================================================================

class Register_Request : public ::google::protobuf::Message {
 public:
  Register_Request();
  virtual ~Register_Request();

  Register_Request(const Register_Request& from);

  inline Register_Request& operator=(const Register_Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Register_Request& default_instance();

  void Swap(Register_Request* other);

  // implements Message ----------------------------------------------

  Register_Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Register_Request& from);
  void MergeFrom(const Register_Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline const ::std::string& code() const;
  inline void set_code(const ::std::string& value);
  inline void set_code(const char* value);
  inline void set_code(const char* value, size_t size);
  inline ::std::string* mutable_code();
  inline ::std::string* release_code();
  inline void set_allocated_code(::std::string* code);

  // optional string birthday = 3;
  inline bool has_birthday() const;
  inline void clear_birthday();
  static const int kBirthdayFieldNumber = 3;
  inline const ::std::string& birthday() const;
  inline void set_birthday(const ::std::string& value);
  inline void set_birthday(const char* value);
  inline void set_birthday(const char* value, size_t size);
  inline ::std::string* mutable_birthday();
  inline ::std::string* release_birthday();
  inline void set_allocated_birthday(::std::string* birthday);

  // optional string telphone = 4;
  inline bool has_telphone() const;
  inline void clear_telphone();
  static const int kTelphoneFieldNumber = 4;
  inline const ::std::string& telphone() const;
  inline void set_telphone(const ::std::string& value);
  inline void set_telphone(const char* value);
  inline void set_telphone(const char* value, size_t size);
  inline ::std::string* mutable_telphone();
  inline ::std::string* release_telphone();
  inline void set_allocated_telphone(::std::string* telphone);

  // optional string mymaxim = 5;
  inline bool has_mymaxim() const;
  inline void clear_mymaxim();
  static const int kMymaximFieldNumber = 5;
  inline const ::std::string& mymaxim() const;
  inline void set_mymaxim(const ::std::string& value);
  inline void set_mymaxim(const char* value);
  inline void set_mymaxim(const char* value, size_t size);
  inline ::std::string* mutable_mymaxim();
  inline ::std::string* release_mymaxim();
  inline void set_allocated_mymaxim(::std::string* mymaxim);

  // optional string image = 6;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 6;
  inline const ::std::string& image() const;
  inline void set_image(const ::std::string& value);
  inline void set_image(const char* value);
  inline void set_image(const char* value, size_t size);
  inline ::std::string* mutable_image();
  inline ::std::string* release_image();
  inline void set_allocated_image(::std::string* image);

  // optional string image_name = 7;
  inline bool has_image_name() const;
  inline void clear_image_name();
  static const int kImageNameFieldNumber = 7;
  inline const ::std::string& image_name() const;
  inline void set_image_name(const ::std::string& value);
  inline void set_image_name(const char* value);
  inline void set_image_name(const char* value, size_t size);
  inline ::std::string* mutable_image_name();
  inline ::std::string* release_image_name();
  inline void set_allocated_image_name(::std::string* image_name);

  // @@protoc_insertion_point(class_scope:Register_Request)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_birthday();
  inline void clear_has_birthday();
  inline void set_has_telphone();
  inline void clear_has_telphone();
  inline void set_has_mymaxim();
  inline void clear_has_mymaxim();
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_image_name();
  inline void clear_has_image_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* code_;
  ::std::string* birthday_;
  ::std::string* telphone_;
  ::std::string* mymaxim_;
  ::std::string* image_;
  ::std::string* image_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_person_2eproto();
  friend void protobuf_AssignDesc_person_2eproto();
  friend void protobuf_ShutdownFile_person_2eproto();

  void InitAsDefaultInstance();
  static Register_Request* default_instance_;
};
// -------------------------------------------------------------------

class Message_Normal : public ::google::protobuf::Message {
 public:
  Message_Normal();
  virtual ~Message_Normal();

  Message_Normal(const Message_Normal& from);

  inline Message_Normal& operator=(const Message_Normal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_Normal& default_instance();

  void Swap(Message_Normal* other);

  // implements Message ----------------------------------------------

  Message_Normal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_Normal& from);
  void MergeFrom(const Message_Normal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string sender = 1;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 1;
  inline const ::std::string& sender() const;
  inline void set_sender(const ::std::string& value);
  inline void set_sender(const char* value);
  inline void set_sender(const char* value, size_t size);
  inline ::std::string* mutable_sender();
  inline ::std::string* release_sender();
  inline void set_allocated_sender(::std::string* sender);

  // optional string reciver = 2;
  inline bool has_reciver() const;
  inline void clear_reciver();
  static const int kReciverFieldNumber = 2;
  inline const ::std::string& reciver() const;
  inline void set_reciver(const ::std::string& value);
  inline void set_reciver(const char* value);
  inline void set_reciver(const char* value, size_t size);
  inline ::std::string* mutable_reciver();
  inline ::std::string* release_reciver();
  inline void set_allocated_reciver(::std::string* reciver);

  // optional string text = 3;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 3;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional string time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // optional string image = 5;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 5;
  inline const ::std::string& image() const;
  inline void set_image(const ::std::string& value);
  inline void set_image(const char* value);
  inline void set_image(const char* value, size_t size);
  inline ::std::string* mutable_image();
  inline ::std::string* release_image();
  inline void set_allocated_image(::std::string* image);

  // optional .message_type type = 6;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 6;
  inline ::message_type type() const;
  inline void set_type(::message_type value);

  // optional int32 messagetype = 7;
  inline bool has_messagetype() const;
  inline void clear_messagetype();
  static const int kMessagetypeFieldNumber = 7;
  inline ::google::protobuf::int32 messagetype() const;
  inline void set_messagetype(::google::protobuf::int32 value);

  // optional string image_name = 8;
  inline bool has_image_name() const;
  inline void clear_image_name();
  static const int kImageNameFieldNumber = 8;
  inline const ::std::string& image_name() const;
  inline void set_image_name(const ::std::string& value);
  inline void set_image_name(const char* value);
  inline void set_image_name(const char* value, size_t size);
  inline ::std::string* mutable_image_name();
  inline ::std::string* release_image_name();
  inline void set_allocated_image_name(::std::string* image_name);

  // repeated string messageall = 9;
  inline int messageall_size() const;
  inline void clear_messageall();
  static const int kMessageallFieldNumber = 9;
  inline const ::std::string& messageall(int index) const;
  inline ::std::string* mutable_messageall(int index);
  inline void set_messageall(int index, const ::std::string& value);
  inline void set_messageall(int index, const char* value);
  inline void set_messageall(int index, const char* value, size_t size);
  inline ::std::string* add_messageall();
  inline void add_messageall(const ::std::string& value);
  inline void add_messageall(const char* value);
  inline void add_messageall(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& messageall() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_messageall();

  // optional string group_name = 10;
  inline bool has_group_name() const;
  inline void clear_group_name();
  static const int kGroupNameFieldNumber = 10;
  inline const ::std::string& group_name() const;
  inline void set_group_name(const ::std::string& value);
  inline void set_group_name(const char* value);
  inline void set_group_name(const char* value, size_t size);
  inline ::std::string* mutable_group_name();
  inline ::std::string* release_group_name();
  inline void set_allocated_group_name(::std::string* group_name);

  // optional string st_name = 11;
  inline bool has_st_name() const;
  inline void clear_st_name();
  static const int kStNameFieldNumber = 11;
  inline const ::std::string& st_name() const;
  inline void set_st_name(const ::std::string& value);
  inline void set_st_name(const char* value);
  inline void set_st_name(const char* value, size_t size);
  inline ::std::string* mutable_st_name();
  inline ::std::string* release_st_name();
  inline void set_allocated_st_name(::std::string* st_name);

  // optional string time_new = 12;
  inline bool has_time_new() const;
  inline void clear_time_new();
  static const int kTimeNewFieldNumber = 12;
  inline const ::std::string& time_new() const;
  inline void set_time_new(const ::std::string& value);
  inline void set_time_new(const char* value);
  inline void set_time_new(const char* value, size_t size);
  inline ::std::string* mutable_time_new();
  inline ::std::string* release_time_new();
  inline void set_allocated_time_new(::std::string* time_new);

  // @@protoc_insertion_point(class_scope:Message_Normal)
 private:
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_reciver();
  inline void clear_has_reciver();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_messagetype();
  inline void clear_has_messagetype();
  inline void set_has_image_name();
  inline void clear_has_image_name();
  inline void set_has_group_name();
  inline void clear_has_group_name();
  inline void set_has_st_name();
  inline void clear_has_st_name();
  inline void set_has_time_new();
  inline void clear_has_time_new();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sender_;
  ::std::string* reciver_;
  ::std::string* text_;
  ::std::string* time_;
  ::std::string* image_;
  int type_;
  ::google::protobuf::int32 messagetype_;
  ::std::string* image_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> messageall_;
  ::std::string* group_name_;
  ::std::string* st_name_;
  ::std::string* time_new_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_person_2eproto();
  friend void protobuf_AssignDesc_person_2eproto();
  friend void protobuf_ShutdownFile_person_2eproto();

  void InitAsDefaultInstance();
  static Message_Normal* default_instance_;
};
// -------------------------------------------------------------------

class Command : public ::google::protobuf::Message {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  void Swap(Command* other);

  // implements Message ----------------------------------------------

  Command* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string use1 = 1;
  inline bool has_use1() const;
  inline void clear_use1();
  static const int kUse1FieldNumber = 1;
  inline const ::std::string& use1() const;
  inline void set_use1(const ::std::string& value);
  inline void set_use1(const char* value);
  inline void set_use1(const char* value, size_t size);
  inline ::std::string* mutable_use1();
  inline ::std::string* release_use1();
  inline void set_allocated_use1(::std::string* use1);

  // optional string use2 = 2;
  inline bool has_use2() const;
  inline void clear_use2();
  static const int kUse2FieldNumber = 2;
  inline const ::std::string& use2() const;
  inline void set_use2(const ::std::string& value);
  inline void set_use2(const char* value);
  inline void set_use2(const char* value, size_t size);
  inline ::std::string* mutable_use2();
  inline ::std::string* release_use2();
  inline void set_allocated_use2(::std::string* use2);

  // optional int32 is_ok = 3;
  inline bool has_is_ok() const;
  inline void clear_is_ok();
  static const int kIsOkFieldNumber = 3;
  inline ::google::protobuf::int32 is_ok() const;
  inline void set_is_ok(::google::protobuf::int32 value);

  // optional string other_use = 4;
  inline bool has_other_use() const;
  inline void clear_other_use();
  static const int kOtherUseFieldNumber = 4;
  inline const ::std::string& other_use() const;
  inline void set_other_use(const ::std::string& value);
  inline void set_other_use(const char* value);
  inline void set_other_use(const char* value, size_t size);
  inline ::std::string* mutable_other_use();
  inline ::std::string* release_other_use();
  inline void set_allocated_other_use(::std::string* other_use);

  // optional int32 other_use1 = 5;
  inline bool has_other_use1() const;
  inline void clear_other_use1();
  static const int kOtherUse1FieldNumber = 5;
  inline ::google::protobuf::int32 other_use1() const;
  inline void set_other_use1(::google::protobuf::int32 value);

  // optional string use3 = 6;
  inline bool has_use3() const;
  inline void clear_use3();
  static const int kUse3FieldNumber = 6;
  inline const ::std::string& use3() const;
  inline void set_use3(const ::std::string& value);
  inline void set_use3(const char* value);
  inline void set_use3(const char* value, size_t size);
  inline ::std::string* mutable_use3();
  inline ::std::string* release_use3();
  inline void set_allocated_use3(::std::string* use3);

  // optional string random_ = 7;
  inline bool has_random_() const;
  inline void clear_random_();
  static const int kRandomFieldNumber = 7;
  inline const ::std::string& random_() const;
  inline void set_random_(const ::std::string& value);
  inline void set_random_(const char* value);
  inline void set_random_(const char* value, size_t size);
  inline ::std::string* mutable_random_();
  inline ::std::string* release_random_();
  inline void set_allocated_random_(::std::string* random_);

  // @@protoc_insertion_point(class_scope:Command)
 private:
  inline void set_has_use1();
  inline void clear_has_use1();
  inline void set_has_use2();
  inline void clear_has_use2();
  inline void set_has_is_ok();
  inline void clear_has_is_ok();
  inline void set_has_other_use();
  inline void clear_has_other_use();
  inline void set_has_other_use1();
  inline void clear_has_other_use1();
  inline void set_has_use3();
  inline void clear_has_use3();
  inline void set_has_random_();
  inline void clear_has_random_();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* use1_;
  ::std::string* use2_;
  ::std::string* other_use_;
  ::google::protobuf::int32 is_ok_;
  ::google::protobuf::int32 other_use1_;
  ::std::string* use3_;
  ::std::string* random__;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_person_2eproto();
  friend void protobuf_AssignDesc_person_2eproto();
  friend void protobuf_ShutdownFile_person_2eproto();

  void InitAsDefaultInstance();
  static Command* default_instance_;
};
// -------------------------------------------------------------------

class Message_ : public ::google::protobuf::Message {
 public:
  Message_();
  virtual ~Message_();

  Message_(const Message_& from);

  inline Message_& operator=(const Message_& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_& default_instance();

  void Swap(Message_* other);

  // implements Message ----------------------------------------------

  Message_* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_& from);
  void MergeFrom(const Message_& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Command_Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Command_Type type() const;
  inline void set_type(::Command_Type value);

  // optional .Command command = 2;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 2;
  inline const ::Command& command() const;
  inline ::Command* mutable_command();
  inline ::Command* release_command();
  inline void set_allocated_command(::Command* command);

  // repeated .Message_Normal message_normal = 3;
  inline int message_normal_size() const;
  inline void clear_message_normal();
  static const int kMessageNormalFieldNumber = 3;
  inline const ::Message_Normal& message_normal(int index) const;
  inline ::Message_Normal* mutable_message_normal(int index);
  inline ::Message_Normal* add_message_normal();
  inline const ::google::protobuf::RepeatedPtrField< ::Message_Normal >&
      message_normal() const;
  inline ::google::protobuf::RepeatedPtrField< ::Message_Normal >*
      mutable_message_normal();

  // optional .Register_Request register_request = 4;
  inline bool has_register_request() const;
  inline void clear_register_request();
  static const int kRegisterRequestFieldNumber = 4;
  inline const ::Register_Request& register_request() const;
  inline ::Register_Request* mutable_register_request();
  inline ::Register_Request* release_register_request();
  inline void set_allocated_register_request(::Register_Request* register_request);

  // optional string id = 5;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 5;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:Message_)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_register_request();
  inline void clear_has_register_request();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Command* command_;
  ::google::protobuf::RepeatedPtrField< ::Message_Normal > message_normal_;
  ::Register_Request* register_request_;
  ::std::string* id_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_person_2eproto();
  friend void protobuf_AssignDesc_person_2eproto();
  friend void protobuf_ShutdownFile_person_2eproto();

  void InitAsDefaultInstance();
  static Message_* default_instance_;
};
// ===================================================================


// ===================================================================

// Register_Request

// required string name = 1;
inline bool Register_Request::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Register_Request::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Register_Request::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Register_Request::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Register_Request::name() const {
  return *name_;
}
inline void Register_Request::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Register_Request::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Register_Request::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register_Request::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Register_Request::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Register_Request::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string code = 2;
inline bool Register_Request::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Register_Request::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Register_Request::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Register_Request::clear_code() {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    code_->clear();
  }
  clear_has_code();
}
inline const ::std::string& Register_Request::code() const {
  return *code_;
}
inline void Register_Request::set_code(const ::std::string& value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void Register_Request::set_code(const char* value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void Register_Request::set_code(const char* value, size_t size) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register_Request::mutable_code() {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  return code_;
}
inline ::std::string* Register_Request::release_code() {
  clear_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_;
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Register_Request::set_allocated_code(::std::string* code) {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    delete code_;
  }
  if (code) {
    set_has_code();
    code_ = code;
  } else {
    clear_has_code();
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string birthday = 3;
inline bool Register_Request::has_birthday() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Register_Request::set_has_birthday() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Register_Request::clear_has_birthday() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Register_Request::clear_birthday() {
  if (birthday_ != &::google::protobuf::internal::kEmptyString) {
    birthday_->clear();
  }
  clear_has_birthday();
}
inline const ::std::string& Register_Request::birthday() const {
  return *birthday_;
}
inline void Register_Request::set_birthday(const ::std::string& value) {
  set_has_birthday();
  if (birthday_ == &::google::protobuf::internal::kEmptyString) {
    birthday_ = new ::std::string;
  }
  birthday_->assign(value);
}
inline void Register_Request::set_birthday(const char* value) {
  set_has_birthday();
  if (birthday_ == &::google::protobuf::internal::kEmptyString) {
    birthday_ = new ::std::string;
  }
  birthday_->assign(value);
}
inline void Register_Request::set_birthday(const char* value, size_t size) {
  set_has_birthday();
  if (birthday_ == &::google::protobuf::internal::kEmptyString) {
    birthday_ = new ::std::string;
  }
  birthday_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register_Request::mutable_birthday() {
  set_has_birthday();
  if (birthday_ == &::google::protobuf::internal::kEmptyString) {
    birthday_ = new ::std::string;
  }
  return birthday_;
}
inline ::std::string* Register_Request::release_birthday() {
  clear_has_birthday();
  if (birthday_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = birthday_;
    birthday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Register_Request::set_allocated_birthday(::std::string* birthday) {
  if (birthday_ != &::google::protobuf::internal::kEmptyString) {
    delete birthday_;
  }
  if (birthday) {
    set_has_birthday();
    birthday_ = birthday;
  } else {
    clear_has_birthday();
    birthday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string telphone = 4;
inline bool Register_Request::has_telphone() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Register_Request::set_has_telphone() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Register_Request::clear_has_telphone() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Register_Request::clear_telphone() {
  if (telphone_ != &::google::protobuf::internal::kEmptyString) {
    telphone_->clear();
  }
  clear_has_telphone();
}
inline const ::std::string& Register_Request::telphone() const {
  return *telphone_;
}
inline void Register_Request::set_telphone(const ::std::string& value) {
  set_has_telphone();
  if (telphone_ == &::google::protobuf::internal::kEmptyString) {
    telphone_ = new ::std::string;
  }
  telphone_->assign(value);
}
inline void Register_Request::set_telphone(const char* value) {
  set_has_telphone();
  if (telphone_ == &::google::protobuf::internal::kEmptyString) {
    telphone_ = new ::std::string;
  }
  telphone_->assign(value);
}
inline void Register_Request::set_telphone(const char* value, size_t size) {
  set_has_telphone();
  if (telphone_ == &::google::protobuf::internal::kEmptyString) {
    telphone_ = new ::std::string;
  }
  telphone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register_Request::mutable_telphone() {
  set_has_telphone();
  if (telphone_ == &::google::protobuf::internal::kEmptyString) {
    telphone_ = new ::std::string;
  }
  return telphone_;
}
inline ::std::string* Register_Request::release_telphone() {
  clear_has_telphone();
  if (telphone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = telphone_;
    telphone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Register_Request::set_allocated_telphone(::std::string* telphone) {
  if (telphone_ != &::google::protobuf::internal::kEmptyString) {
    delete telphone_;
  }
  if (telphone) {
    set_has_telphone();
    telphone_ = telphone;
  } else {
    clear_has_telphone();
    telphone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mymaxim = 5;
inline bool Register_Request::has_mymaxim() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Register_Request::set_has_mymaxim() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Register_Request::clear_has_mymaxim() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Register_Request::clear_mymaxim() {
  if (mymaxim_ != &::google::protobuf::internal::kEmptyString) {
    mymaxim_->clear();
  }
  clear_has_mymaxim();
}
inline const ::std::string& Register_Request::mymaxim() const {
  return *mymaxim_;
}
inline void Register_Request::set_mymaxim(const ::std::string& value) {
  set_has_mymaxim();
  if (mymaxim_ == &::google::protobuf::internal::kEmptyString) {
    mymaxim_ = new ::std::string;
  }
  mymaxim_->assign(value);
}
inline void Register_Request::set_mymaxim(const char* value) {
  set_has_mymaxim();
  if (mymaxim_ == &::google::protobuf::internal::kEmptyString) {
    mymaxim_ = new ::std::string;
  }
  mymaxim_->assign(value);
}
inline void Register_Request::set_mymaxim(const char* value, size_t size) {
  set_has_mymaxim();
  if (mymaxim_ == &::google::protobuf::internal::kEmptyString) {
    mymaxim_ = new ::std::string;
  }
  mymaxim_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register_Request::mutable_mymaxim() {
  set_has_mymaxim();
  if (mymaxim_ == &::google::protobuf::internal::kEmptyString) {
    mymaxim_ = new ::std::string;
  }
  return mymaxim_;
}
inline ::std::string* Register_Request::release_mymaxim() {
  clear_has_mymaxim();
  if (mymaxim_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mymaxim_;
    mymaxim_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Register_Request::set_allocated_mymaxim(::std::string* mymaxim) {
  if (mymaxim_ != &::google::protobuf::internal::kEmptyString) {
    delete mymaxim_;
  }
  if (mymaxim) {
    set_has_mymaxim();
    mymaxim_ = mymaxim;
  } else {
    clear_has_mymaxim();
    mymaxim_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string image = 6;
inline bool Register_Request::has_image() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Register_Request::set_has_image() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Register_Request::clear_has_image() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Register_Request::clear_image() {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    image_->clear();
  }
  clear_has_image();
}
inline const ::std::string& Register_Request::image() const {
  return *image_;
}
inline void Register_Request::set_image(const ::std::string& value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void Register_Request::set_image(const char* value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void Register_Request::set_image(const char* value, size_t size) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register_Request::mutable_image() {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  return image_;
}
inline ::std::string* Register_Request::release_image() {
  clear_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_;
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Register_Request::set_allocated_image(::std::string* image) {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    delete image_;
  }
  if (image) {
    set_has_image();
    image_ = image;
  } else {
    clear_has_image();
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string image_name = 7;
inline bool Register_Request::has_image_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Register_Request::set_has_image_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Register_Request::clear_has_image_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Register_Request::clear_image_name() {
  if (image_name_ != &::google::protobuf::internal::kEmptyString) {
    image_name_->clear();
  }
  clear_has_image_name();
}
inline const ::std::string& Register_Request::image_name() const {
  return *image_name_;
}
inline void Register_Request::set_image_name(const ::std::string& value) {
  set_has_image_name();
  if (image_name_ == &::google::protobuf::internal::kEmptyString) {
    image_name_ = new ::std::string;
  }
  image_name_->assign(value);
}
inline void Register_Request::set_image_name(const char* value) {
  set_has_image_name();
  if (image_name_ == &::google::protobuf::internal::kEmptyString) {
    image_name_ = new ::std::string;
  }
  image_name_->assign(value);
}
inline void Register_Request::set_image_name(const char* value, size_t size) {
  set_has_image_name();
  if (image_name_ == &::google::protobuf::internal::kEmptyString) {
    image_name_ = new ::std::string;
  }
  image_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register_Request::mutable_image_name() {
  set_has_image_name();
  if (image_name_ == &::google::protobuf::internal::kEmptyString) {
    image_name_ = new ::std::string;
  }
  return image_name_;
}
inline ::std::string* Register_Request::release_image_name() {
  clear_has_image_name();
  if (image_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_name_;
    image_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Register_Request::set_allocated_image_name(::std::string* image_name) {
  if (image_name_ != &::google::protobuf::internal::kEmptyString) {
    delete image_name_;
  }
  if (image_name) {
    set_has_image_name();
    image_name_ = image_name;
  } else {
    clear_has_image_name();
    image_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Message_Normal

// optional string sender = 1;
inline bool Message_Normal::has_sender() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message_Normal::set_has_sender() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message_Normal::clear_has_sender() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message_Normal::clear_sender() {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    sender_->clear();
  }
  clear_has_sender();
}
inline const ::std::string& Message_Normal::sender() const {
  return *sender_;
}
inline void Message_Normal::set_sender(const ::std::string& value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void Message_Normal::set_sender(const char* value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void Message_Normal::set_sender(const char* value, size_t size) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message_Normal::mutable_sender() {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  return sender_;
}
inline ::std::string* Message_Normal::release_sender() {
  clear_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sender_;
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Message_Normal::set_allocated_sender(::std::string* sender) {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    delete sender_;
  }
  if (sender) {
    set_has_sender();
    sender_ = sender;
  } else {
    clear_has_sender();
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string reciver = 2;
inline bool Message_Normal::has_reciver() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message_Normal::set_has_reciver() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message_Normal::clear_has_reciver() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message_Normal::clear_reciver() {
  if (reciver_ != &::google::protobuf::internal::kEmptyString) {
    reciver_->clear();
  }
  clear_has_reciver();
}
inline const ::std::string& Message_Normal::reciver() const {
  return *reciver_;
}
inline void Message_Normal::set_reciver(const ::std::string& value) {
  set_has_reciver();
  if (reciver_ == &::google::protobuf::internal::kEmptyString) {
    reciver_ = new ::std::string;
  }
  reciver_->assign(value);
}
inline void Message_Normal::set_reciver(const char* value) {
  set_has_reciver();
  if (reciver_ == &::google::protobuf::internal::kEmptyString) {
    reciver_ = new ::std::string;
  }
  reciver_->assign(value);
}
inline void Message_Normal::set_reciver(const char* value, size_t size) {
  set_has_reciver();
  if (reciver_ == &::google::protobuf::internal::kEmptyString) {
    reciver_ = new ::std::string;
  }
  reciver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message_Normal::mutable_reciver() {
  set_has_reciver();
  if (reciver_ == &::google::protobuf::internal::kEmptyString) {
    reciver_ = new ::std::string;
  }
  return reciver_;
}
inline ::std::string* Message_Normal::release_reciver() {
  clear_has_reciver();
  if (reciver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reciver_;
    reciver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Message_Normal::set_allocated_reciver(::std::string* reciver) {
  if (reciver_ != &::google::protobuf::internal::kEmptyString) {
    delete reciver_;
  }
  if (reciver) {
    set_has_reciver();
    reciver_ = reciver;
  } else {
    clear_has_reciver();
    reciver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string text = 3;
inline bool Message_Normal::has_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message_Normal::set_has_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message_Normal::clear_has_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message_Normal::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& Message_Normal::text() const {
  return *text_;
}
inline void Message_Normal::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Message_Normal::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Message_Normal::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message_Normal::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* Message_Normal::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Message_Normal::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string time = 4;
inline bool Message_Normal::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message_Normal::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message_Normal::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message_Normal::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& Message_Normal::time() const {
  return *time_;
}
inline void Message_Normal::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void Message_Normal::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void Message_Normal::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message_Normal::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* Message_Normal::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Message_Normal::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string image = 5;
inline bool Message_Normal::has_image() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message_Normal::set_has_image() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Message_Normal::clear_has_image() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Message_Normal::clear_image() {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    image_->clear();
  }
  clear_has_image();
}
inline const ::std::string& Message_Normal::image() const {
  return *image_;
}
inline void Message_Normal::set_image(const ::std::string& value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void Message_Normal::set_image(const char* value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void Message_Normal::set_image(const char* value, size_t size) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message_Normal::mutable_image() {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  return image_;
}
inline ::std::string* Message_Normal::release_image() {
  clear_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_;
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Message_Normal::set_allocated_image(::std::string* image) {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    delete image_;
  }
  if (image) {
    set_has_image();
    image_ = image;
  } else {
    clear_has_image();
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .message_type type = 6;
inline bool Message_Normal::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Message_Normal::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Message_Normal::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Message_Normal::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::message_type Message_Normal::type() const {
  return static_cast< ::message_type >(type_);
}
inline void Message_Normal::set_type(::message_type value) {
  assert(::message_type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int32 messagetype = 7;
inline bool Message_Normal::has_messagetype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Message_Normal::set_has_messagetype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Message_Normal::clear_has_messagetype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Message_Normal::clear_messagetype() {
  messagetype_ = 0;
  clear_has_messagetype();
}
inline ::google::protobuf::int32 Message_Normal::messagetype() const {
  return messagetype_;
}
inline void Message_Normal::set_messagetype(::google::protobuf::int32 value) {
  set_has_messagetype();
  messagetype_ = value;
}

// optional string image_name = 8;
inline bool Message_Normal::has_image_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Message_Normal::set_has_image_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Message_Normal::clear_has_image_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Message_Normal::clear_image_name() {
  if (image_name_ != &::google::protobuf::internal::kEmptyString) {
    image_name_->clear();
  }
  clear_has_image_name();
}
inline const ::std::string& Message_Normal::image_name() const {
  return *image_name_;
}
inline void Message_Normal::set_image_name(const ::std::string& value) {
  set_has_image_name();
  if (image_name_ == &::google::protobuf::internal::kEmptyString) {
    image_name_ = new ::std::string;
  }
  image_name_->assign(value);
}
inline void Message_Normal::set_image_name(const char* value) {
  set_has_image_name();
  if (image_name_ == &::google::protobuf::internal::kEmptyString) {
    image_name_ = new ::std::string;
  }
  image_name_->assign(value);
}
inline void Message_Normal::set_image_name(const char* value, size_t size) {
  set_has_image_name();
  if (image_name_ == &::google::protobuf::internal::kEmptyString) {
    image_name_ = new ::std::string;
  }
  image_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message_Normal::mutable_image_name() {
  set_has_image_name();
  if (image_name_ == &::google::protobuf::internal::kEmptyString) {
    image_name_ = new ::std::string;
  }
  return image_name_;
}
inline ::std::string* Message_Normal::release_image_name() {
  clear_has_image_name();
  if (image_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_name_;
    image_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Message_Normal::set_allocated_image_name(::std::string* image_name) {
  if (image_name_ != &::google::protobuf::internal::kEmptyString) {
    delete image_name_;
  }
  if (image_name) {
    set_has_image_name();
    image_name_ = image_name;
  } else {
    clear_has_image_name();
    image_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string messageall = 9;
inline int Message_Normal::messageall_size() const {
  return messageall_.size();
}
inline void Message_Normal::clear_messageall() {
  messageall_.Clear();
}
inline const ::std::string& Message_Normal::messageall(int index) const {
  return messageall_.Get(index);
}
inline ::std::string* Message_Normal::mutable_messageall(int index) {
  return messageall_.Mutable(index);
}
inline void Message_Normal::set_messageall(int index, const ::std::string& value) {
  messageall_.Mutable(index)->assign(value);
}
inline void Message_Normal::set_messageall(int index, const char* value) {
  messageall_.Mutable(index)->assign(value);
}
inline void Message_Normal::set_messageall(int index, const char* value, size_t size) {
  messageall_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message_Normal::add_messageall() {
  return messageall_.Add();
}
inline void Message_Normal::add_messageall(const ::std::string& value) {
  messageall_.Add()->assign(value);
}
inline void Message_Normal::add_messageall(const char* value) {
  messageall_.Add()->assign(value);
}
inline void Message_Normal::add_messageall(const char* value, size_t size) {
  messageall_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Message_Normal::messageall() const {
  return messageall_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Message_Normal::mutable_messageall() {
  return &messageall_;
}

// optional string group_name = 10;
inline bool Message_Normal::has_group_name() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Message_Normal::set_has_group_name() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Message_Normal::clear_has_group_name() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Message_Normal::clear_group_name() {
  if (group_name_ != &::google::protobuf::internal::kEmptyString) {
    group_name_->clear();
  }
  clear_has_group_name();
}
inline const ::std::string& Message_Normal::group_name() const {
  return *group_name_;
}
inline void Message_Normal::set_group_name(const ::std::string& value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
}
inline void Message_Normal::set_group_name(const char* value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
}
inline void Message_Normal::set_group_name(const char* value, size_t size) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message_Normal::mutable_group_name() {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  return group_name_;
}
inline ::std::string* Message_Normal::release_group_name() {
  clear_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_name_;
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Message_Normal::set_allocated_group_name(::std::string* group_name) {
  if (group_name_ != &::google::protobuf::internal::kEmptyString) {
    delete group_name_;
  }
  if (group_name) {
    set_has_group_name();
    group_name_ = group_name;
  } else {
    clear_has_group_name();
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string st_name = 11;
inline bool Message_Normal::has_st_name() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Message_Normal::set_has_st_name() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Message_Normal::clear_has_st_name() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Message_Normal::clear_st_name() {
  if (st_name_ != &::google::protobuf::internal::kEmptyString) {
    st_name_->clear();
  }
  clear_has_st_name();
}
inline const ::std::string& Message_Normal::st_name() const {
  return *st_name_;
}
inline void Message_Normal::set_st_name(const ::std::string& value) {
  set_has_st_name();
  if (st_name_ == &::google::protobuf::internal::kEmptyString) {
    st_name_ = new ::std::string;
  }
  st_name_->assign(value);
}
inline void Message_Normal::set_st_name(const char* value) {
  set_has_st_name();
  if (st_name_ == &::google::protobuf::internal::kEmptyString) {
    st_name_ = new ::std::string;
  }
  st_name_->assign(value);
}
inline void Message_Normal::set_st_name(const char* value, size_t size) {
  set_has_st_name();
  if (st_name_ == &::google::protobuf::internal::kEmptyString) {
    st_name_ = new ::std::string;
  }
  st_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message_Normal::mutable_st_name() {
  set_has_st_name();
  if (st_name_ == &::google::protobuf::internal::kEmptyString) {
    st_name_ = new ::std::string;
  }
  return st_name_;
}
inline ::std::string* Message_Normal::release_st_name() {
  clear_has_st_name();
  if (st_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = st_name_;
    st_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Message_Normal::set_allocated_st_name(::std::string* st_name) {
  if (st_name_ != &::google::protobuf::internal::kEmptyString) {
    delete st_name_;
  }
  if (st_name) {
    set_has_st_name();
    st_name_ = st_name;
  } else {
    clear_has_st_name();
    st_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string time_new = 12;
inline bool Message_Normal::has_time_new() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Message_Normal::set_has_time_new() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Message_Normal::clear_has_time_new() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Message_Normal::clear_time_new() {
  if (time_new_ != &::google::protobuf::internal::kEmptyString) {
    time_new_->clear();
  }
  clear_has_time_new();
}
inline const ::std::string& Message_Normal::time_new() const {
  return *time_new_;
}
inline void Message_Normal::set_time_new(const ::std::string& value) {
  set_has_time_new();
  if (time_new_ == &::google::protobuf::internal::kEmptyString) {
    time_new_ = new ::std::string;
  }
  time_new_->assign(value);
}
inline void Message_Normal::set_time_new(const char* value) {
  set_has_time_new();
  if (time_new_ == &::google::protobuf::internal::kEmptyString) {
    time_new_ = new ::std::string;
  }
  time_new_->assign(value);
}
inline void Message_Normal::set_time_new(const char* value, size_t size) {
  set_has_time_new();
  if (time_new_ == &::google::protobuf::internal::kEmptyString) {
    time_new_ = new ::std::string;
  }
  time_new_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message_Normal::mutable_time_new() {
  set_has_time_new();
  if (time_new_ == &::google::protobuf::internal::kEmptyString) {
    time_new_ = new ::std::string;
  }
  return time_new_;
}
inline ::std::string* Message_Normal::release_time_new() {
  clear_has_time_new();
  if (time_new_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_new_;
    time_new_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Message_Normal::set_allocated_time_new(::std::string* time_new) {
  if (time_new_ != &::google::protobuf::internal::kEmptyString) {
    delete time_new_;
  }
  if (time_new) {
    set_has_time_new();
    time_new_ = time_new;
  } else {
    clear_has_time_new();
    time_new_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Command

// optional string use1 = 1;
inline bool Command::has_use1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command::set_has_use1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command::clear_has_use1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command::clear_use1() {
  if (use1_ != &::google::protobuf::internal::kEmptyString) {
    use1_->clear();
  }
  clear_has_use1();
}
inline const ::std::string& Command::use1() const {
  return *use1_;
}
inline void Command::set_use1(const ::std::string& value) {
  set_has_use1();
  if (use1_ == &::google::protobuf::internal::kEmptyString) {
    use1_ = new ::std::string;
  }
  use1_->assign(value);
}
inline void Command::set_use1(const char* value) {
  set_has_use1();
  if (use1_ == &::google::protobuf::internal::kEmptyString) {
    use1_ = new ::std::string;
  }
  use1_->assign(value);
}
inline void Command::set_use1(const char* value, size_t size) {
  set_has_use1();
  if (use1_ == &::google::protobuf::internal::kEmptyString) {
    use1_ = new ::std::string;
  }
  use1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command::mutable_use1() {
  set_has_use1();
  if (use1_ == &::google::protobuf::internal::kEmptyString) {
    use1_ = new ::std::string;
  }
  return use1_;
}
inline ::std::string* Command::release_use1() {
  clear_has_use1();
  if (use1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = use1_;
    use1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command::set_allocated_use1(::std::string* use1) {
  if (use1_ != &::google::protobuf::internal::kEmptyString) {
    delete use1_;
  }
  if (use1) {
    set_has_use1();
    use1_ = use1;
  } else {
    clear_has_use1();
    use1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string use2 = 2;
inline bool Command::has_use2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command::set_has_use2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command::clear_has_use2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command::clear_use2() {
  if (use2_ != &::google::protobuf::internal::kEmptyString) {
    use2_->clear();
  }
  clear_has_use2();
}
inline const ::std::string& Command::use2() const {
  return *use2_;
}
inline void Command::set_use2(const ::std::string& value) {
  set_has_use2();
  if (use2_ == &::google::protobuf::internal::kEmptyString) {
    use2_ = new ::std::string;
  }
  use2_->assign(value);
}
inline void Command::set_use2(const char* value) {
  set_has_use2();
  if (use2_ == &::google::protobuf::internal::kEmptyString) {
    use2_ = new ::std::string;
  }
  use2_->assign(value);
}
inline void Command::set_use2(const char* value, size_t size) {
  set_has_use2();
  if (use2_ == &::google::protobuf::internal::kEmptyString) {
    use2_ = new ::std::string;
  }
  use2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command::mutable_use2() {
  set_has_use2();
  if (use2_ == &::google::protobuf::internal::kEmptyString) {
    use2_ = new ::std::string;
  }
  return use2_;
}
inline ::std::string* Command::release_use2() {
  clear_has_use2();
  if (use2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = use2_;
    use2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command::set_allocated_use2(::std::string* use2) {
  if (use2_ != &::google::protobuf::internal::kEmptyString) {
    delete use2_;
  }
  if (use2) {
    set_has_use2();
    use2_ = use2;
  } else {
    clear_has_use2();
    use2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 is_ok = 3;
inline bool Command::has_is_ok() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command::set_has_is_ok() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command::clear_has_is_ok() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command::clear_is_ok() {
  is_ok_ = 0;
  clear_has_is_ok();
}
inline ::google::protobuf::int32 Command::is_ok() const {
  return is_ok_;
}
inline void Command::set_is_ok(::google::protobuf::int32 value) {
  set_has_is_ok();
  is_ok_ = value;
}

// optional string other_use = 4;
inline bool Command::has_other_use() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Command::set_has_other_use() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Command::clear_has_other_use() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Command::clear_other_use() {
  if (other_use_ != &::google::protobuf::internal::kEmptyString) {
    other_use_->clear();
  }
  clear_has_other_use();
}
inline const ::std::string& Command::other_use() const {
  return *other_use_;
}
inline void Command::set_other_use(const ::std::string& value) {
  set_has_other_use();
  if (other_use_ == &::google::protobuf::internal::kEmptyString) {
    other_use_ = new ::std::string;
  }
  other_use_->assign(value);
}
inline void Command::set_other_use(const char* value) {
  set_has_other_use();
  if (other_use_ == &::google::protobuf::internal::kEmptyString) {
    other_use_ = new ::std::string;
  }
  other_use_->assign(value);
}
inline void Command::set_other_use(const char* value, size_t size) {
  set_has_other_use();
  if (other_use_ == &::google::protobuf::internal::kEmptyString) {
    other_use_ = new ::std::string;
  }
  other_use_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command::mutable_other_use() {
  set_has_other_use();
  if (other_use_ == &::google::protobuf::internal::kEmptyString) {
    other_use_ = new ::std::string;
  }
  return other_use_;
}
inline ::std::string* Command::release_other_use() {
  clear_has_other_use();
  if (other_use_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = other_use_;
    other_use_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command::set_allocated_other_use(::std::string* other_use) {
  if (other_use_ != &::google::protobuf::internal::kEmptyString) {
    delete other_use_;
  }
  if (other_use) {
    set_has_other_use();
    other_use_ = other_use;
  } else {
    clear_has_other_use();
    other_use_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 other_use1 = 5;
inline bool Command::has_other_use1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Command::set_has_other_use1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Command::clear_has_other_use1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Command::clear_other_use1() {
  other_use1_ = 0;
  clear_has_other_use1();
}
inline ::google::protobuf::int32 Command::other_use1() const {
  return other_use1_;
}
inline void Command::set_other_use1(::google::protobuf::int32 value) {
  set_has_other_use1();
  other_use1_ = value;
}

// optional string use3 = 6;
inline bool Command::has_use3() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Command::set_has_use3() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Command::clear_has_use3() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Command::clear_use3() {
  if (use3_ != &::google::protobuf::internal::kEmptyString) {
    use3_->clear();
  }
  clear_has_use3();
}
inline const ::std::string& Command::use3() const {
  return *use3_;
}
inline void Command::set_use3(const ::std::string& value) {
  set_has_use3();
  if (use3_ == &::google::protobuf::internal::kEmptyString) {
    use3_ = new ::std::string;
  }
  use3_->assign(value);
}
inline void Command::set_use3(const char* value) {
  set_has_use3();
  if (use3_ == &::google::protobuf::internal::kEmptyString) {
    use3_ = new ::std::string;
  }
  use3_->assign(value);
}
inline void Command::set_use3(const char* value, size_t size) {
  set_has_use3();
  if (use3_ == &::google::protobuf::internal::kEmptyString) {
    use3_ = new ::std::string;
  }
  use3_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command::mutable_use3() {
  set_has_use3();
  if (use3_ == &::google::protobuf::internal::kEmptyString) {
    use3_ = new ::std::string;
  }
  return use3_;
}
inline ::std::string* Command::release_use3() {
  clear_has_use3();
  if (use3_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = use3_;
    use3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command::set_allocated_use3(::std::string* use3) {
  if (use3_ != &::google::protobuf::internal::kEmptyString) {
    delete use3_;
  }
  if (use3) {
    set_has_use3();
    use3_ = use3;
  } else {
    clear_has_use3();
    use3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string random_ = 7;
inline bool Command::has_random_() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Command::set_has_random_() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Command::clear_has_random_() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Command::clear_random_() {
  if (random__ != &::google::protobuf::internal::kEmptyString) {
    random__->clear();
  }
  clear_has_random_();
}
inline const ::std::string& Command::random_() const {
  return *random__;
}
inline void Command::set_random_(const ::std::string& value) {
  set_has_random_();
  if (random__ == &::google::protobuf::internal::kEmptyString) {
    random__ = new ::std::string;
  }
  random__->assign(value);
}
inline void Command::set_random_(const char* value) {
  set_has_random_();
  if (random__ == &::google::protobuf::internal::kEmptyString) {
    random__ = new ::std::string;
  }
  random__->assign(value);
}
inline void Command::set_random_(const char* value, size_t size) {
  set_has_random_();
  if (random__ == &::google::protobuf::internal::kEmptyString) {
    random__ = new ::std::string;
  }
  random__->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command::mutable_random_() {
  set_has_random_();
  if (random__ == &::google::protobuf::internal::kEmptyString) {
    random__ = new ::std::string;
  }
  return random__;
}
inline ::std::string* Command::release_random_() {
  clear_has_random_();
  if (random__ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = random__;
    random__ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command::set_allocated_random_(::std::string* random_) {
  if (random__ != &::google::protobuf::internal::kEmptyString) {
    delete random__;
  }
  if (random_) {
    set_has_random_();
    random__ = random_;
  } else {
    clear_has_random_();
    random__ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Message_

// required .Command_Type type = 1;
inline bool Message_::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message_::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message_::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message_::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::Command_Type Message_::type() const {
  return static_cast< ::Command_Type >(type_);
}
inline void Message_::set_type(::Command_Type value) {
  assert(::Command_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .Command command = 2;
inline bool Message_::has_command() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message_::set_has_command() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message_::clear_has_command() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message_::clear_command() {
  if (command_ != NULL) command_->::Command::Clear();
  clear_has_command();
}
inline const ::Command& Message_::command() const {
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
inline ::Command* Message_::mutable_command() {
  set_has_command();
  if (command_ == NULL) command_ = new ::Command;
  return command_;
}
inline ::Command* Message_::release_command() {
  clear_has_command();
  ::Command* temp = command_;
  command_ = NULL;
  return temp;
}
inline void Message_::set_allocated_command(::Command* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
}

// repeated .Message_Normal message_normal = 3;
inline int Message_::message_normal_size() const {
  return message_normal_.size();
}
inline void Message_::clear_message_normal() {
  message_normal_.Clear();
}
inline const ::Message_Normal& Message_::message_normal(int index) const {
  return message_normal_.Get(index);
}
inline ::Message_Normal* Message_::mutable_message_normal(int index) {
  return message_normal_.Mutable(index);
}
inline ::Message_Normal* Message_::add_message_normal() {
  return message_normal_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Message_Normal >&
Message_::message_normal() const {
  return message_normal_;
}
inline ::google::protobuf::RepeatedPtrField< ::Message_Normal >*
Message_::mutable_message_normal() {
  return &message_normal_;
}

// optional .Register_Request register_request = 4;
inline bool Message_::has_register_request() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message_::set_has_register_request() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message_::clear_has_register_request() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message_::clear_register_request() {
  if (register_request_ != NULL) register_request_->::Register_Request::Clear();
  clear_has_register_request();
}
inline const ::Register_Request& Message_::register_request() const {
  return register_request_ != NULL ? *register_request_ : *default_instance_->register_request_;
}
inline ::Register_Request* Message_::mutable_register_request() {
  set_has_register_request();
  if (register_request_ == NULL) register_request_ = new ::Register_Request;
  return register_request_;
}
inline ::Register_Request* Message_::release_register_request() {
  clear_has_register_request();
  ::Register_Request* temp = register_request_;
  register_request_ = NULL;
  return temp;
}
inline void Message_::set_allocated_register_request(::Register_Request* register_request) {
  delete register_request_;
  register_request_ = register_request;
  if (register_request) {
    set_has_register_request();
  } else {
    clear_has_register_request();
  }
}

// optional string id = 5;
inline bool Message_::has_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message_::set_has_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Message_::clear_has_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Message_::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Message_::id() const {
  return *id_;
}
inline void Message_::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Message_::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Message_::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message_::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Message_::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Message_::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message_type>() {
  return ::message_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Command_Type>() {
  return ::Command_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_person_2eproto__INCLUDED
